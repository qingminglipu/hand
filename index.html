<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æŒ¥æ‰‹ç²’å­ç³»ç»Ÿï¼ˆé˜²è¯¯è§¦ç‰ˆï¼‰</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        #input_video { 
            position: absolute; top: 0; left: 0; opacity: 0; z-index: -1; 
            width: 1px; height: 1px; pointer-events: none;
        }
        
        /* é¡¶éƒ¨æç¤ºæ  */
        #ui-panel {
            position: absolute; top: 20px; left: 0; right: 0;
            text-align: center; pointer-events: none; z-index: 10;
        }

        /* å½“å‰å½¢çŠ¶åç§°çš„å¤§æ ‡é¢˜ */
        #shape-name {
            font-size: 32px; font-weight: bold; color: white;
            text-shadow: 0 0 10px rgba(0,255,200,0.8);
            transition: transform 0.3s;
        }

        /* æ“ä½œæç¤º */
        .instruction {
            color: rgba(255,255,255,0.7); font-size: 14px; margin-top: 5px;
            background: rgba(0,0,0,0.4); display: inline-block;
            padding: 4px 12px; border-radius: 20px;
        }

        /* åˆ‡æ¢æ—¶çš„å¼¹çª—æç¤º (Toast) */
        #toast {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 20px 40px; border-radius: 15px;
            color: #fff; font-size: 24px; font-weight: bold;
            opacity: 0; transition: all 0.3s; pointer-events: none;
            border: 1px solid rgba(255,255,255,0.3);
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 50;
        }
        #toast.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffc8; font-size: 18px; z-index: 200; text-align: center;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
        }
    </style>
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...<br><span style="font-size:12px;color:#ccc">é¦–æ¬¡åŠ è½½è¾ƒæ…¢ï¼Œè¯·ç¨å€™</span></div>

    <div id="ui-panel">
        <div id="shape-name">â¤ï¸ çˆ±å¿ƒ</div>
        <div class="instruction">ğŸ‘‹ å‘å·¦/å‘å³æŒ¥æ‰‹åˆ‡æ¢å½¢çŠ¶ | ğŸ¤ æåˆæ‰‹æŒ‡ç¼©æ”¾</div>
    </div>

    <!-- åˆ‡æ¢æç¤ºæ¡† -->
    <div id="toast"></div>

    <video id="input_video" playsinline webkit-playsinline muted autoplay></video>

<script>
    // ================= é…ç½®å‚æ•° =================
    const PARTICLE_COUNT = 15000;
    const PARTICLE_SIZE = 0.25;
    
    // å½¢çŠ¶åˆ—è¡¨å®šä¹‰
    const SHAPE_LIST = [
        { key: 'heart', name: 'â¤ï¸ çˆ±å¿ƒ', color: '#ff0055' },
        { key: 'flower', name: 'ğŸŒ¸ èŠ±æœµ', color: '#ff66b2' },
        { key: 'saturn', name: 'ğŸª åœŸæ˜Ÿ', color: '#00ccff' },
        { key: 'buddha', name: 'ğŸ§˜ ä½›åƒ', color: '#ffcc00' },
        { key: 'fireworks', name: 'ğŸ† çƒŸèŠ±', color: '#aa00ff' },
        { key: 'sphere', name: 'ğŸ”® çƒä½“', color: '#00ffc8' }
    ];

    let currentShapeIndex = 0; // å½“å‰å½¢çŠ¶ç´¢å¼•
    let handInteractionFactor = 1.0;
    let targetColor = new THREE.Color(SHAPE_LIST[0].color);

    // ================= THREE.JS åˆå§‹åŒ– =================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 25;

    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // ================= ç²’å­ç³»ç»Ÿ =================
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 50;
        targetPositions[i] = positions[i];
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        color: targetColor,
        transparent: true,
        opacity: 0.85,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // ================= å½¢çŠ¶ç®—æ³• =================
    function getPointOnSphere(r) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
    }

    const ShapeGenerators = {
        heart: () => {
            const t = Math.random() * Math.PI * 2, u = Math.random() * Math.PI;
            const x = 16 * Math.pow(Math.sin(u), 3) * Math.sin(t);
            const y = (13 * Math.cos(u) - 5 * Math.cos(2*u) - 2 * Math.cos(3*u) - Math.cos(4*u));
            const z = 16 * Math.pow(Math.sin(u), 3) * Math.cos(t) * 0.5;
            return [x * 0.6, y * 0.6, z * 0.6];
        },
        saturn: () => {
            if (Math.random() > 0.4) {
                const angle = Math.random() * Math.PI * 2, dist = 9 + Math.random() * 4;
                return [Math.cos(angle) * dist, (Math.random()-0.5)*0.5, Math.sin(angle) * dist];
            }
            const p = getPointOnSphere(5); return [p.x, p.y, p.z];
        },
        flower: () => {
            const u = Math.random() * Math.PI * 4, v = Math.random() * Math.PI * 2;
            const rad = 8 * Math.sin(3 * u);
            return [rad * Math.sin(u) * Math.cos(v), rad * Math.cos(u) * Math.cos(v) + 4, rad * Math.sin(v)];
        },
        buddha: () => {
            const r = Math.random();
            let p, yOffset;
            if (r < 0.25) { p = getPointOnSphere(2); yOffset = 6; }
            else if (r < 0.65) { p = getPointOnSphere(4.5); p.y*=0.8; yOffset = 1; }
            else { p = getPointOnSphere(6); p.y*=0.4; yOffset = -4; }
            return [p.x, p.y + yOffset, p.z];
        },
        fireworks: () => { const p = getPointOnSphere(Math.random() * 15); return [p.x, p.y, p.z]; },
        sphere: () => { const p = getPointOnSphere(10); return [p.x, p.y, p.z]; }
    };

    function updateParticlesTarget(shapeKey) {
        const generator = ShapeGenerators[shapeKey];
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const pos = generator(i);
            targetPositions[i * 3] = pos[0];
            targetPositions[i * 3 + 1] = pos[1];
            targetPositions[i * 3 + 2] = pos[2];
        }
    }
    updateParticlesTarget('heart'); // é»˜è®¤åˆå§‹å½¢çŠ¶

    // ================= åˆ‡æ¢é€»è¾‘ (Toast UI) =================
    const toast = document.getElementById('toast');
    let toastTimer;

    function showToast(text, direction) {
        toast.innerText = (direction === 'next' ? 'â© ' : 'âª ') + text;
        toast.classList.add('show');
        
        // ç¼©æ”¾ä¸€ä¸‹æ ‡é¢˜äº§ç”Ÿè§†è§‰åé¦ˆ
        const title = document.getElementById('shape-name');
        title.style.transform = "scale(1.2)";
        setTimeout(() => title.style.transform = "scale(1)", 200);

        clearTimeout(toastTimer);
        toastTimer = setTimeout(() => {
            toast.classList.remove('show');
        }, 1500);
    }

    function switchShape(step) {
        // è®¡ç®—æ–°ç´¢å¼• (å¤„ç†å¾ªç¯)
        currentShapeIndex = (currentShapeIndex + step + SHAPE_LIST.length) % SHAPE_LIST.length;
        
        const shapeData = SHAPE_LIST[currentShapeIndex];
        
        // æ›´æ–° UI
        document.getElementById('shape-name').innerText = shapeData.name;
        document.getElementById('shape-name').style.color = shapeData.color;
        showToast(shapeData.name, step > 0 ? 'next' : 'prev');

        // æ›´æ–°ç²’å­ç›®æ ‡å’Œé¢œè‰²
        updateParticlesTarget(shapeData.key);
        targetColor.set(shapeData.color);
    }

    // ================= MediaPipe æ‰‹åŠ¿ä¸æŒ¥æ‰‹æ£€æµ‹ (é˜²è¯¯è§¦ç‰ˆ) =================
    const videoElement = document.getElementById('input_video');
    
    // ã€æ ¸å¿ƒä¿®æ”¹1ã€‘è°ƒæ•´æŒ¥æ‰‹æ£€æµ‹å‚æ•°ï¼Œé™ä½çµæ•åº¦
    const SWIPE_THRESHOLD = 0.08; // ä»0.03è°ƒå›0.08ï¼Œéœ€è¦æ›´å¤§çš„ä½ç§»æ‰è§¦å‘
    const COOLDOWN_MS = 1000;      // ä»600msè°ƒå›1000msï¼Œå»¶é•¿å†·å´æ—¶é—´
    const SWIPE_WINDOW = 8;        // ä»5å¸§å¢è‡³8å¸§ï¼Œåˆ¤å®šæ›´ç¨³å®š
    let wristXHistory = [];        // å­˜å‚¨æœ€è¿‘çš„æ‰‹è…•Xåæ ‡
    let lastSwitchTime = 0;
    let lastWristX = null;

    // ã€æ ¸å¿ƒä¿®æ”¹2ã€‘æé«˜æ‰‹éƒ¨æ£€æµ‹ç½®ä¿¡åº¦ï¼Œå‡å°‘è¯¯æ£€æµ‹
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,          
        minDetectionConfidence: 0.5, // ä»0.3è°ƒå›0.5ï¼Œè¿‡æ»¤æ¨¡ç³Šæ‰‹éƒ¨è½®å»“
        minTrackingConfidence: 0.5,  // ä»0.3è°ƒå›0.5ï¼Œæå‡è·Ÿè¸ªç¨³å®šæ€§
        selfieMode: true             
    });

    hands.onResults((results) => {
        document.getElementById('loading').style.display = 'none';
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 1. æåˆç¼©æ”¾é€»è¾‘
            const thumb = landmarks[4];
            const index = landmarks[8];
            const dist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2) + Math.pow(thumb.z - index.z, 2));
            let pinchFactor = (dist - 0.01) * 8; 
            pinchFactor = Math.max(0.1, Math.min(2.5, pinchFactor + 0.4));
            handInteractionFactor += (pinchFactor - handInteractionFactor) * 0.25;

            // 2. æŒ¥æ‰‹æ£€æµ‹é€»è¾‘ï¼ˆã€æ ¸å¿ƒä¿®æ”¹3ã€‘å¢åŠ æ–¹å‘ä¸€è‡´æ€§æ ¡éªŒï¼‰
            const currWristX = landmarks[0].x;
            const now = Date.now();

            // ç»´æŠ¤æœ€è¿‘8å¸§çš„æ‰‹è…•Xåæ ‡ï¼Œè¿‡æ»¤å¾®å°æŠ–åŠ¨
            wristXHistory.push(currWristX);
            if (wristXHistory.length > SWIPE_WINDOW) {
                wristXHistory.shift();
            }

            if (wristXHistory.length === SWIPE_WINDOW && (now - lastSwitchTime > COOLDOWN_MS)) {
                // è®¡ç®—æ—¶é—´çª—å£å†…çš„æ€»ä½ç§»
                const totalDiff = wristXHistory[wristXHistory.length - 1] - wristXHistory[0];
                
                // ã€æ ¸å¿ƒä¿®æ”¹4ã€‘å¢åŠ æ–¹å‘ä¸€è‡´æ€§æ£€æŸ¥ï¼šç¡®ä¿è¿ç»­å¸§éƒ½æ˜¯åŒä¸€æ–¹å‘ç§»åŠ¨
                let isDirectionConsistent = true;
                for (let i = 1; i < wristXHistory.length; i++) {
                    const frameDiff = wristXHistory[i] - wristXHistory[i-1];
                    // å¦‚æœæŸä¸€å¸§çš„ç§»åŠ¨æ–¹å‘ä¸æ€»ä½ç§»æ–¹å‘ç›¸åï¼Œåˆ¤å®šä¸ºæŠ–åŠ¨
                    if (Math.sign(frameDiff) !== Math.sign(totalDiff) && Math.abs(frameDiff) > 0.01) {
                        isDirectionConsistent = false;
                        break;
                    }
                }

                // åªæœ‰ä½ç§»è¾¾æ ‡ä¸”æ–¹å‘ä¸€è‡´æ—¶ï¼Œæ‰è§¦å‘æŒ¥æ‰‹åˆ‡æ¢
                if (isDirectionConsistent) {
                    if (totalDiff > SWIPE_THRESHOLD) {
                        switchShape(1); 
                        lastSwitchTime = now;
                        wristXHistory = []; 
                    } else if (totalDiff < -SWIPE_THRESHOLD) {
                        switchShape(-1); 
                        lastSwitchTime = now;
                        wristXHistory = []; 
                    }
                }
            }

            lastWristX = currWristX;

        } else {
            // æ²¡æ£€æµ‹åˆ°æ‰‹ï¼Œé‡ç½®çŠ¶æ€
            handInteractionFactor += (1.0 - handInteractionFactor) * 0.1;
            lastWristX = null;
            wristXHistory = [];
        }
    });

    // æ‘„åƒå¤´é…ç½®
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280,  
        height: 720,  
        facingMode: 'user'
    });
    cameraUtils.start();

    // ================= åŠ¨ç”»å¾ªç¯ =================
    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;
        
        material.color.lerp(targetColor, 0.15);
        
        particles.rotation.y = time * 0.2;
        particles.rotation.x = time * 0.05;
        
        const posArr = particles.geometry.attributes.position.array;
        const currentKey = SHAPE_LIST[currentShapeIndex].key;
        const isFireworks = currentKey === 'fireworks';
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3, iy = ix + 1, iz = ix + 2;
            let tx = targetPositions[ix], ty = targetPositions[iy], tz = targetPositions[iz];

            // çƒŸèŠ±ç‰¹æ®ŠåŠ¨æ€
            if (isFireworks) {
                const pulse = 1 + Math.sin(time * 5) * 0.6;
                tx *= pulse; ty *= pulse; tz *= pulse;
            }

            // åº”ç”¨æ‰‹åŠ¿ç¼©æ”¾
            tx *= handInteractionFactor; ty *= handInteractionFactor; tz *= handInteractionFactor;
            
            // å‡å°‘éšæœºå™ªç‚¹
            tx += (Math.random()-0.5)*0.1; ty += (Math.random()-0.5)*0.1; tz += (Math.random()-0.5)*0.1;

            // ç²’å­ç§»åŠ¨é€Ÿåº¦
            posArr[ix] += (tx - posArr[ix]) * 0.15;
            posArr[iy] += (ty - posArr[iy]) * 0.15;
            posArr[iz] += (tz - posArr[iz]) * 0.15;
        }
        
        particles.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    animate();
</script>
</body>
</html>
